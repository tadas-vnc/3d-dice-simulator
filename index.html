<!DOCTYPE html>
<html>
<head>
    <title>3D Dice Simulator</title>
    <style>
        body { 
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #rollButton {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: background 0.3s ease;
        }
        #rollButton:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
    <button id="rollButton">Roll Dice</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        let camera, scene, renderer, world, dice, physicsBody;
        const diceGeometry = new THREE.BoxGeometry(1, 1, 1);

        function createDotTexture(dotCount) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, 256, 256);
            
            context.fillStyle = '#000000';
            const dotRadius = 20;
            const gridSize = 3;
            const spacing = canvas.width / (gridSize + 1);

            function drawDot(row, col) {
                const x = spacing * (col + 1);
                const y = spacing * (row + 1);
                context.beginPath();
                context.arc(x, y, dotRadius, 0, Math.PI * 2);
                context.fill();
            }

            // Dot configurations for each face
            const dotConfigurations = [
                [],                         // 0 (not used)
                [[1,1]],                    // 1
                [[0,0], [2,2]],             // 2
                [[0,0], [1,1], [2,2]],      // 3
                [[0,0], [0,2], [2,0], [2,2]], // 4
                [[0,0], [0,2], [1,1], [2,0], [2,2]], // 5
                [[0,0], [0,2], [1,0], [1,2], [2,0], [2,2]] // 6
            ];

            const dots = dotConfigurations[dotCount];
            dots.forEach(dot => {
                drawDot(dot[0], dot[1]);
            });

            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 0);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({ mass: 0 });
            floorBody.addShape(floorShape);
            floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(floorBody);

            createDice();
            
            document.getElementById('rollButton').addEventListener('click', rollDice);
        }

        function createDice() {
            const materials = [];
            
            // Create materials with dot textures for each face
            for(let i = 1; i <= 6; i++) {
                const texture = createDotTexture(i);
                materials.push(new THREE.MeshStandardMaterial({ 
                    map: texture,
                    roughness: 0.5,
                    metalness: 0.3
                }));
            }

            dice = new THREE.Mesh(diceGeometry, materials);
            dice.castShadow = true;
            scene.add(dice);
            
            const shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
            physicsBody = new CANNON.Body({ mass: 1 });
            physicsBody.addShape(shape);
            world.addBody(physicsBody);
        }

        function rollDice() {
            const randomX = (Math.random() - 0.5) * 4;
            const randomZ = (Math.random() - 0.5) * 4;
            physicsBody.position.set(randomX, 8, randomZ);
            physicsBody.velocity.set(0, 0, 0);
            physicsBody.angularVelocity.set(
                Math.random() * 10 - 5,
                Math.random() * 10 - 5,
                Math.random() * 10 - 5
            );
            
            physicsBody.quaternion.setFromEuler(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
        }

        function animate() {
            requestAnimationFrame(animate);
            world.step(1/60);
            if(dice && physicsBody) {
                dice.position.copy(physicsBody.position);
                dice.quaternion.copy(physicsBody.quaternion);
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
        animate();
    </script>
</body>
</html>
