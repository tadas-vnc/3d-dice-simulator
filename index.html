<!DOCTYPE html>
<html>
<head>
    <title>3D Dice Simulator</title>
    <style>
        body { 
            margin: 0;
            overflow: hidden;
        }
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #rollButton {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <button id="rollButton">Roll Dice</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        let camera, scene, renderer, world, dice, physicsBody;
        const diceGeometry = new THREE.BoxGeometry(1, 1, 1);

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 0);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({ mass: 0 });
            floorBody.addShape(floorShape);
            floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(floorBody);

            createDice();
            
            document.getElementById('rollButton').addEventListener('click', rollDice);
        }

        function createDice() {
            const materials = [];
            const textureLoader = new THREE.TextureLoader();
            
            for(let i = 1; i <= 6; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                context.fillStyle = '#ffffff';
                context.fillRect(0, 0, 128, 128);
                context.font = 'bold 80px Arial';
                context.fillStyle = '#000000';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(i.toString(), 64, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                materials.push(new THREE.MeshStandardMaterial({ map: texture }));
            }

            dice = new THREE.Mesh(diceGeometry, materials);
            dice.castShadow = true;
            scene.add(dice);
            const shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
            physicsBody = new CANNON.Body({ mass: 1 });
            physicsBody.addShape(shape);
            world.addBody(physicsBody);
        }

        function rollDice() {
            const randomX = (Math.random() - 0.5) * 4;
            const randomZ = (Math.random() - 0.5) * 4;
            physicsBody.position.set(randomX, 8, randomZ);
            physicsBody.velocity.set(0, 0, 0);
            physicsBody.angularVelocity.set(
                Math.random() * 10 - 5,
                Math.random() * 10 - 5,
                Math.random() * 10 - 5
            );
            
            physicsBody.quaternion.setFromEuler(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
        }

        function animate() {
            requestAnimationFrame(animate);
            world.step(1/60);
            if(dice && physicsBody) {
                dice.position.copy(physicsBody.position);
                dice.quaternion.copy(physicsBody.quaternion);
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
        animate();
    </script>
</body>
</html>